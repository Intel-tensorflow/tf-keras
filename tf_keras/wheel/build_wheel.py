# Copyright 2025 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""Build the TF-Keras pip package.

The steps are as follows:

1. List and import every file in codebase, so we can inspect the symbols the
  codebase contains.
2. Use the annotations left by the `keras_export` decorator to filter the
  symbols that should be exported, as well as their export path (default one
  and v1 one).
3. Use this information to generate `__init__.py` files in
  `tf_keras/`.
4. Run the setup script to write out build artifacts to `tf_keras/dist`.
"""

import argparse
import glob
import importlib
import inspect
import os
import pathlib
import platform
import shutil
import subprocess
import sys

PACKAGE_NAME = "tf_keras"
SRC_DIRNAME = "src"
INIT_FILE_HEADER = """AUTOGENERATED. DO NOT EDIT."""
# These are symbols that have export issues and that we skip for now.
SYMBOLS_TO_SKIP = ["layer_test"]

parser = argparse.ArgumentParser(fromfile_prefix_chars="@")
parser.add_argument(
    "--copied_whl_srcs_dir",
    default=None,
    required=True,
)
parser.add_argument(
    "--whl_dir",
    default=None,
    required=True,
)
parser.add_argument(
    "--src_directory",
    required=True,
    default=None,
)
parser.add_argument(
    "--version",
    type=str,
    help="Wheel version.",
)
parser.add_argument(
    "--build-wheel-only",
    default=False,
    help="Whether to build the wheel only. Optional.",
)
parser.add_argument(
    "--build-source-package-only",
    default=False,
    help="Whether to build the source package only. Optional.",
)
args = parser.parse_args()


def generate_keras_api_files(
    package_directory, src_directory, copied_whl_srcs_dir
):
    codebase_walk_entry_points = []
    for root, _, files in os.walk(src_directory):
        for fname in files:
            parts = root.split("/")
            parts = parts[parts.index(PACKAGE_NAME) :]
            base_entry_point = ".".join(parts)
            if fname == "__init__.py":
                codebase_walk_entry_points.append(base_entry_point)
            elif fname.endswith(".py") and not fname.endswith("_test.py"):
                module_name = fname[:-3]
                codebase_walk_entry_points.append(
                    base_entry_point + "." + module_name
                )

    # Import all Python modules found in the code directory.
    modules = []
    for entry_point in codebase_walk_entry_points:
        copied_whl_srcs_dir_name = os.path.basename(copied_whl_srcs_dir)
        entry_point = entry_point.replace(
            f"{PACKAGE_NAME}.wheel.{copied_whl_srcs_dir_name}.", ""
        )
        mod = importlib.import_module(entry_point, package=".")
        modules.append(mod)

    # Populate list of all symbols to register.
    all_symbols = set()
    processed = set()
    from tensorflow.python.util import tf_decorator

    for module in modules:
        for name in dir(module):
            if name in SYMBOLS_TO_SKIP:
                continue
            symbol = getattr(module, name)

            # Get the real symbol behind any TF decorator
            try:
                _, symbol = tf_decorator.unwrap(symbol)
            except ModuleNotFoundError:
                # unwrap will not work on a ModuleSpec (which can't be
                # an API symbol anyway)
                continue

            # Skip if already seen
            if id(symbol) in processed:
                continue
            processed.add(id(symbol))

            try:
                if not hasattr(symbol, "_keras_api_names"):
                    continue
            except:  # noqa: E722
                continue
            # If the symbol is a non-registered subclass of
            # a registered symbol, skip it.
            skip = False

            def has_same_metadata(a, b):
                if (
                    hasattr(a, "_keras_api_names")
                    and hasattr(b, "_keras_api_names")
                    and a._keras_api_names == b._keras_api_names
                    and a._keras_api_names_v1 == b._keras_api_names_v1
                ):
                    return True
                return False

            try:
                classes = inspect.getmro(symbol)
                if len(classes) >= 2:
                    parents = classes[1:]
                    for p in parents:
                        if has_same_metadata(p, symbol):
                            skip = True
            except AttributeError:
                # getmro will error out on a non-class
                # (in which case there can be no subclassing issues).
                pass
            if not skip:
                all_symbols.add(symbol)

    # Generate __init__ files content.
    init_files_content = grab_symbol_metadata(all_symbols, is_v1=False)
    init_files_content_v1 = grab_symbol_metadata(all_symbols, is_v1=True)

    write_out_api_files(
        init_files_content,
        target_dir=pathlib.Path(package_directory).parent.resolve(),
    )
    v1_path = os.path.join(package_directory, "api", "_v1")
    v2_path = os.path.join(package_directory, "api", "_v2")
    write_out_api_files(
        init_files_content,
        target_dir=v2_path,
        root_offset=["api", "_v2", "keras"],
    )
    write_out_api_files(
        init_files_content_v1,
        target_dir=v1_path,
        root_offset=["api", "_v1", "keras"],
    )
    # Add missing __init__ files in api dirs.
    with open(os.path.join(package_directory, "api", "__init__.py"), "w"):
        pass
    with open(os.path.join(v1_path, "__init__.py"), "w"):
        pass
    with open(os.path.join(v2_path, "__init__.py"), "w"):
        pass


def grab_symbol_metadata(all_symbols, is_v1=False):
    # init_files_content is a dict mapping a directory path to a list of
    # symbol metadata entries to populate the __init__ file for the directory.
    # Each entry is a dict with keys 'symbol' and 'export_name'.
    init_files_content = {}
    for symbol in all_symbols:
        if is_v1:
            api_names = symbol._keras_api_names_v1
        else:
            api_names = symbol._keras_api_names
        for export_path in api_names:
            export_modules = export_path.split(".")
            export_name = export_modules[-1]
            parent_path = os.path.join(*export_modules[:-1])
            if parent_path not in init_files_content:
                init_files_content[parent_path] = []
            init_files_content[parent_path].append(
                {"symbol": symbol, "export_name": export_name}
            )
            for i in range(1, len(export_modules[:-1])):
                intermediate_path = os.path.join(*export_modules[:i])
                if intermediate_path not in init_files_content:
                    init_files_content[intermediate_path] = []
                init_files_content[intermediate_path].append(
                    {
                        "module": export_modules[i],
                        "location": ".".join(export_modules[:i]),
                    }
                )
    return init_files_content


def write_out_api_files(init_files_content, target_dir, root_offset=None):
    # Go over init_files_content, make dirs,
    # create __init__.py file, populate file with public symbol imports.
    root_offset = root_offset or []
    for path, contents in init_files_content.items():
        # Use`tf_keras.<module>` format.
        module_path = path
        if path.startswith("keras"):
            module_path = "tf_" + module_path
        # Change pathnames from keras/layers -> tf_keras/layers unless
        # root_offset is explitly provided for API generation.
        if path.startswith("keras") and not root_offset:
            path = "tf_" + path
        os.makedirs(os.path.join(target_dir, path), exist_ok=True)
        init_file_lines = []
        modules_included = set()
        for symbol_metadata in contents:
            if "symbol" in symbol_metadata:
                symbol = symbol_metadata["symbol"]
                name = symbol_metadata["export_name"]
                if name == symbol.__name__:
                    init_file_lines.append(
                        f"from {symbol.__module__} import {symbol.__name__}"
                    )
                else:
                    init_file_lines.append(
                        f"from {symbol.__module__} import {symbol.__name__}"
                        + f" as {name}"
                    )
            elif "module" in symbol_metadata:
                if symbol_metadata["module"] not in modules_included:
                    parts = module_path.split("/")
                    parts = [parts[0]] + root_offset + parts[1:]
                    module_location = ".".join(parts)
                    init_file_lines.append(
                        f"from {module_location} import"
                        + f" {symbol_metadata['module']}"
                    )
                    modules_included.add(symbol_metadata["module"])

        init_path = os.path.join(target_dir, path, "__init__.py")
        init_file_lines = sorted(init_file_lines)
        with open(init_path, "w") as f:
            contents = (
                f'"""{INIT_FILE_HEADER}"""\n\n'
                + "\n".join(init_file_lines)
                + "\n"
            )
            f.write(contents)
        os.chmod(init_path, 0o644)


def copy_src_directory(src_directory, destination_path):
    for root, dirs, files in os.walk(src_directory):
        relative_path = os.path.relpath(root, src_directory)
        dest_root = os.path.join(destination_path, relative_path)
        os.makedirs(dest_root, exist_ok=True)
        for f in files:
            src_file = os.path.join(root, f)
            dest_file = os.path.join(dest_root, f)
            shutil.copy2(src_file, dest_file)
            os.chmod(dest_file, 0o644)


def build_pip_package(src_directory, copied_whl_srcs_dir, whl_dir, version):
    copy_src_directory(src_directory, copied_whl_srcs_dir)

    generate_keras_api_files(
        package_directory=os.path.join(copied_whl_srcs_dir, PACKAGE_NAME),
        src_directory=os.path.join(
            copied_whl_srcs_dir, PACKAGE_NAME, SRC_DIRNAME
        ),
        copied_whl_srcs_dir=copied_whl_srcs_dir,
    )

    # Make sure to export the __version__ string
    with open(
        os.path.join(copied_whl_srcs_dir, PACKAGE_NAME, "__init__.py")
    ) as f:
        init_contents = f.read()
    with open(
        os.path.join(copied_whl_srcs_dir, PACKAGE_NAME, "__init__.py"), "w"
    ) as f:
        f.write(init_contents + "\n\n" + f'__version__ = "{version}"\n')

    subprocess.run(
        [sys.executable, "-m", "build", "-n"]
        + (["-w"] if args.build_wheel_only else [])
        + (["-s"] if args.build_source_package_only else []),
        check=True,
        cwd=copied_whl_srcs_dir,
    )

    for wheel in glob.glob(os.path.join(copied_whl_srcs_dir, "dist", "*.whl")):
        output_file = os.path.join(whl_dir, os.path.basename(wheel))
        sys.stderr.write(f"Output wheel: {output_file}\n\n")
        sys.stderr.write(
            f"To install the newly-built {PACKAGE_NAME} wheel "
            + "on system Python, run:\n"
        )
        sys.stderr.write(f"  pip install {output_file} --force-reinstall\n\n")

        py_version = ".".join(platform.python_version_tuple()[:-1])
        sys.stderr.write(
            f"To install the newly-built {PACKAGE_NAME} wheel "
            + "on hermetic Python, run:\n"
        )
        sys.stderr.write(
            f'  echo -e "\\n{output_file}" >> build/requirements.in\n'
        )
        sys.stderr.write(
            "  bazel run //:requirements.update"
            + f" --repo_env=HERMETIC_PYTHON_VERSION={py_version}\n\n"
        )
        shutil.copy(wheel, whl_dir)
        os.chmod(output_file, 0o644)
    if args.build_source_package_only:
        for dist in glob.glob(
            os.path.join(copied_whl_srcs_dir, "dist", "*.tar.gz")
        ):
            output_file = os.path.join(whl_dir, os.path.basename(dist))
            sys.stderr.write(f"Output source package: {output_file}\n\n")
            shutil.copy(dist, whl_dir)
            os.chmod(output_file, 0o644)


if __name__ == "__main__":
    os.makedirs(args.copied_whl_srcs_dir, exist_ok=True)
    os.makedirs(args.whl_dir, exist_ok=True)
    build_pip_package(
        src_directory=args.src_directory,
        copied_whl_srcs_dir=pathlib.Path(args.copied_whl_srcs_dir),
        whl_dir=pathlib.Path(args.whl_dir),
        version=args.version,
    )
